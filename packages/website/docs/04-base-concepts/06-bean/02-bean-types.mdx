---
title: Bean Types
id: bean-type
---

Bean type is a type of value that bean will provide as a dependency for other beans.

There are a few restrictions on bean value types: `undefined`, `void`, `null`, `never` or union type.
If you specify an invalid bean type, you will get compile-time error.
Let's take a look at invalid bean types:

```mdx-code-block
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
<TabItem value="undefined-void-null-never" label="undefined, void, null, never">
```

```ts
class MyContext extends CatContext {
  @Bean foo: undefined = undefined;
  @Bean bar: void = undefined;
  @Bean baz: null = null;
  @Bean quux(): never { throw new Error('never'); }
}
```

```mdx-code-block
</TabItem>

<TabItem value="union-type" label="union">
```

```ts
class MyContext extends CatContext {
  @Bean foo: string | number = 'string';
}
```

```mdx-code-block
</TabItem>
</Tabs>
```

## Specifying Bean type
You can specify the type explicitly for each property,
but it is not necessary to, because Clawject using TypeScript type system to infer types.

The next two examples are equivalent:

```mdx-code-block
<Tabs>
<TabItem value="infer-type" label="Infering type based on value">
```

```ts
class MyContext extends CatContext {
  @Bean foo = 'fooValue'; // <- type of Bean will be "string"
}
```

```mdx-code-block
</TabItem>

<TabItem value="explicitly-specify-type" label="Specify type explicitly">
```

```ts
class MyContext extends CatContext {
  @Bean foo: string = 'fooValue'; // <- type of Bean will be "string"
}
```

```mdx-code-block
</TabItem>
</Tabs>
```

When your bean type is a class-type -
Clawject will automatically resolve a class type including `implements` and `extends` clauses types.

Note that only first level of `extends` and `implements` clauses will be resolved,
so if your class extends another class, and that class extends another class, -
only a first class type will be resolved.

Let's take a look at the next example:

```ts
class AbstractBar {}
class AbstractFoo extends AbstractBar {}

interface IFoo {}

class Foo extends AbstractFoo implements IFoo {}

class MyContext extends CatContext {
  foo = Bean(Foo);

  @PostConstruct
  postConstruct(
    foo: Foo, // <- "foo" will be injected
    iFoo: IFoo, // <- "foo" will be injected, "Foo" explicitly implements "IFoo"
    abstractFoo: AbstractFoo, // <- "foo" will be injected, "Foo" explicitly extends "AbstractFoo"
    abstractBar: AbstractBar, // <- compilation error will be reported, no bean of type "AbstractBar" were found
  ) {}
}
```

If you don't want to resolve `implements` and `extends` types,
you can specify a type of bean explicitly, or disable this feature globally.
TODO link to configuration guide

```ts
interface IFoo {}
class Foo implements IFoo {}

class MyContext extends CatContext {
  foo: IFoo = Bean(Foo);

  @PostConstruct
  postConstruct(
    iFoo: IFoo, // <- "foo" will be injected by explicit type
    foo: Foo, // <- compilation error will be reported, no bean of type "Foo" were found
  ) {}
}
```
