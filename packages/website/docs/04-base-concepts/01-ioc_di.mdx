---
title: Intro to IoC and DI
id: ioc-di
---

<br/>

# Intro to Inversion of Control and Dependency Injection with Clawject

## Overview

In this section, we will explore the principles of Inversion of Control (IoC) and Dependency Injection (DI),
and take a look at how these are implemented in Clawject.

## What is Inversion of Control?

***Inversion of Control*** is a principle in software engineering which transfers the control
of objects or portions of a program to a container or framework.
We most often use it in the context of object-oriented programming.

In contrast with traditional programming, in which our custom code makes calls to a library,
the IoC enables a framework to take control of the flow of a program and make calls to our custom code.
To enable this, frameworks use abstractions with additional behavior built in.

The advantages of this architecture are:
- Decoupling the execution of a task from its implementation
- Making it easier to switch between different implementations
- Greater modularity of a program
- Greater ease in testing a program by isolating a component or mocking its dependencies
and allowing components to communicate through contracts

One of the ways we can achieve Inversion of Control is a Dependency Injection (DI).

## What is Dependency Injection?
Dependency injection is a pattern we can use to implement IoC,
where the control being inverted is setting an object's dependencies.

Connecting objects with other objects, or “***injecting***” objects into other objects, is done by an assembler rather than by the objects themselves.

Here's how we would create an object dependency in traditional programming:

```ts
class Store {
  private item: Item;

  constructor() {
    this.item = new ItemImpl();
  }
}
```

By using DI, we can rewrite the example without specifying the implementation of the Item that we want:
```ts
class Store {
  constructor(
    private item: Item
  ) {}
}
```

## The Clawject IoC container

An IoC container is a common characteristic of frameworks that implement IoC.

In the Clawject, the interface CatContext represents the IoC container.
The Clawject container is responsible for instantiating, configuring and assembling objects known as beans,
as well as managing their life cycles.

Right now Clawject provides one way to manage IoC containers. This is ContainerManager interface.

Here is the way to instantiate container:

```ts
class ApplicationContext extends CatContext {}

ContainerManager.init(ApplicationContext);
```

## Constructor-Based Dependency Injection

In the case of constructor-based dependency injection,
the container will invoke a constructor with arguments each representing a dependency we want to set.

Clawject resolves each argument primarily by type, followed by the name of the constructor parameter.
Let's see the configuration of a bean and its dependencies using Bean call:

```ts
class Bar {}
class Foo {
  constructor(private bar: Bar) {}
}

class ApplicationContext extends CatContext {
  foo = Bean(Foo)
  bar = Bean(Bar)
}
```

We're assigning a Bean call result to a class property to define a bean.
Bean name is a property name.

For a bean with the default singleton scope, Clawject first checks if a cached instance of the bean already exists,
and only creates a new one if it doesn't.
If we're using the prototype scope, the container returns a new bean instance for each bean instance request.

Let's see how we can define a bean with the prototype scope:

In this example, we have two beans that require the ***Baz*** instance,
for each of which the container creates a new instance of ***Baz*** class.

```ts
class Baz {}
class Bar {
  constructor(private baz: Baz) {}
}
class Foo {
  constructor(private baz: Baz) {}
}

class ApplicationContext extends CatContext {
  foo = Bean(Foo)
  bar = Bean(Bar)

  @Scope('prototype')
  baz = Bean(Baz)
}
```

## Lazy Initialized Beans
By default, the container creates and configures all singleton beans during initialization.
To avoid this, we can use the ***lazy*** decorator with on the bean configuration level:

**foo** bean will only be initialized when it's first requested, and not at startup.

```ts
class ApplicationContext extends CatContext {
  @Lazy
  foo = Bean(Foo)
}
```

You can redefine the default lazy value for all beans in clawject configuration file TODO ADD LINK
